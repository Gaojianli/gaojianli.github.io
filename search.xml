<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[树莓派添加温控风扇（一）]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言前不久不知道树莓派抽什么风，风扇的噪音突然变得奇大无比，弄得潇叫苦连连。虽然我亲自去听了之后觉得声音远远比不上他的神舟和那台安装了FreeBSD的古董机，但毕竟有求于人，这样下去也不是个办法。稍加分析不难得出，风扇声音大是因为24小时常开导致了积灰和磨损，尤其是前者更是难以避免。而我树莓派大部分时候都处于闲置状态，风扇其实是没必要24小时上线的。那么，能不能让风扇按需启动呢？这样一来可以改善噪音问题，同时树莓派困扰许久的供电不足问题也能够得到相应的改善。 初步思路那么，如何用树莓派控制风扇呢？不同于PC主板，树莓派并没有能够直接控制风扇的接口，因此要想控制风扇只有通过那26PIN的GPIO来实现。首先我们来查一下树莓派的引脚：我平时长通使用的就是右侧的4，6号针脚，而需要控制的话，右侧的12号，14号针脚看起来是个理想的选择。 安装wiringPi在树莓派上想要轻松地使用GPIO针脚需要用到wiringPi这个库，它可以让我们用C或者C++对树莓派的GPIO针脚进行控制。安装过程非常简单，跟着官网教程走就行了：123git clone git://git.drogon.net/wiringPicd wiringPi./build 竟然不是make略微让我吃惊，不过安装完成没出什么幺蛾子就好(这个flag…)。 编写控制代码其实整个程序的逻辑并不复杂，也就是 获取温度 根据预先写好的规则进行判断 调整GPIO输出 相关代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;wiringPi.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt; #define TEMP_PATH "/sys/class/thermal/thermal_zone0/temp" #define MAX_SIZE 20 #define GPIO_PIN 18float getTemp();int main(void)&#123; if (wiringPiSetupGpio() == -1) //初始化GPIO &#123; fprintf(stderr,"Setup wiringPi failed!"); return -1; &#125; pinMode(GPIO_PIN, OUTPUT);//设定输出模式 float temp; bool status = false; while (true) &#123; temp = getTemp(); if (temp &gt; 50) &#123; digitalWrite(GPIO_PIN, 1);//开启风扇 status = true; &#125; else if(temp&lt;40 &amp;&amp;status) &#123; digitalWrite(GPIO_PIN, 0);//关闭风扇 status = false; &#125; delay(5000); &#125; return 0;&#125;float getTemp(void)//获取温度函数&#123; int fd; float temp = 0; char buf[MAX_SIZE]; fd = open(TEMP_PATH, O_RDONLY); if (fd &lt; 0) &#123; fprintf(stderr, "failed to open thermal_zone0/temp\n"); return -1; &#125; if (read(fd, buf, MAX_SIZE) &lt; 0) &#123; fprintf(stderr, "failed to read temp\n"); return -1; &#125; temp = atoi(buf) / 1000.0; close(fd); return temp;&#125; 编译这部分就是非常基础了，总之先测试一下：1g++ main.cpp -lwiringPi ~看起来并没有遇到什么问题~，那么接下来就尝试运行一下吧。 碰壁12345# root @ rasp in ~/projects/AutoFan [14:43:28]$ ./a.outOops: Unable to determine board revision from /proc/cpuinfo -&gt; No &quot;Hardware&quot; line -&gt; You&apos;d best google the error to find out why. 喵喵喵？这什么鬼。。看起来是不认我的cpuinfo？赶紧cat一下:123456789101112131415161718192021222324252627282930313233343536cat cpuinfoprocessor : 0BogoMIPS : 38.40Features : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant : 0x0CPU part : 0xd03CPU revision : 4processor : 1BogoMIPS : 38.40Features : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant : 0x0CPU part : 0xd03CPU revision : 4processor : 2BogoMIPS : 38.40Features : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant : 0x0CPU part : 0xd03CPU revision : 4processor : 3BogoMIPS : 38.40Features : fp asimd evtstrm crc32 cpuidCPU implementer : 0x41CPU architecture: 8CPU variant : 0x0CPU part : 0xd03CPU revision : 4 这就奇怪了，确实没有硬件相关的字段。。难道是我内核的问题？之前为了所谓的性能提升，我给树莓派安装的是64位Debian，并不是官方的通用Raspbian。 原因在翻了大半天github之后，我找到了这个issue接着又被导引到这个，里面这个疑似内核维护者的人写道： 1.We aren’t supporting 64-bit builds, although if there are simple things we can do (like hosting defconfigs for arm64) then we will.2.When we do support arm64 it will be with the absolute minimum number of changes to the upstream kernel (ideally none), and the content of /proc/cpuinfo would not be high on the list of priorities. Board revision number and serial number are concepts that don’t appear to exist in the arm64 architecture, but we will continue to make that information available via /proc/device-tree/system/linux,revision and /proc/device-tree/system/linux,serial, with human-readable versions in /proc/device-tree/model and /proc/device-tree/serial-number 大意就是树莓派linux从未支持过arm64，并且arm64的上游内核决定在cpuinfo里面显示更少的信息，并将版本号等信息移到/proc/device-tree/model等地去，他们决定对上游内核做尽可能少的修改，因此不打算修复这个不算bug的问题。所有我能做的就是等待wiringPi等库更新，以兼容arm64。 后续很遗憾，根据这个issue提出的日期来看，他们是没有兼容的意向的，因此我现在就维持在一种凉凉的状态。只能说，这就是使用小众系统的代价，找不到文档或者社区支持已经是常态，BSD也好，slackware也好，都是这样。对于这种问题来讲目前是没有什么好思路的，今天天色也不早了，问题留到明天在看看吧。つづく]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客添加Gitalk评论插件]]></title>
    <url>%2F2018%2F07%2F24%2F%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言一直以来都想要给自己的博客弄个评论系统，但是hexo作为一个静态博客，本身是不可能具有这种功能的，只能仰仗第三方插件。这方面的插件也非常多，比如disqus、vline等。但这些插件都存在或多或少问题，比如注册麻烦或者干脆国内不能访问。考虑到我家长城宽带的现实，必须选择一个在各地都能流畅访问的插件，这里我选择了Gitalk. 简介先来看看官网的简介吧： Gitalk is a modern comment component based on GitHub Issue and Preact. 顾名思义，这是一个基于GitHub的issue功能构建的评论系统。为了部署方便，我的博客本身也是托管在GitHub上的，而且其CDN也遍布全球各地，即使是长城宽带也能保证访问。此外相信本文的绝大多数读者也都具有GitHub账号，这也省去了大家注册的麻烦。因此，从各种意义上来说，它都是一个理想的插件。 安装官方提供了2种安装方式：直接引用和npm。直接引用：1234567&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"&gt;&lt;script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"&gt;&lt;/script&gt;&lt;!-- or --&gt;&lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt;&lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt; npm:12npm installnpm i --save gitalk 12import 'gitalk/dist/gitalk.css'import Gitalk from 'gitalk' 就我个人而言我是想使用npm的，但是无奈才疏学浅，研究了半天也没找到该怎么import，只好采用第一种方法了。如果读者找到了方法，还望在评论区不吝赐教。 使用创建OAuth应用既然是要让大家在issue里面进行提问，肯定是需要GitHub授权的，因此我们需要先注册一个OAuth应用。虽然理论上来说随便新建一个仓库即可，但是我既然已经有博客这一仓库了，干脆就直接把它注册成GitHub应用算了。注册链接在这里，Application name填写你的仓库名，记得Homepage URL和Authorization callback URL一栏一定要填写博客网址，否则授权后无法正常跳转。完成后请记录下clientID和clientSecret，待会儿要用。已经创建的OAuth应用可以在设置查看。 魔改主题配置文件主题方面，NexT本身就支持了许多评论插件，但很不幸，Gitalk并不在其中。幸运的是NexT使用统一接口接入评论服务，因此我们只需要修改模板文件即可。拓展阅读：Swig(swig-templates)不是SWIG (Simplified Wrapper and Interface Generator) ，别弄混了。前者是模板引擎，后者是“简化包以及接口生成器”。 新增Gitalk的模板文件定位到next/layout/_third-party/comments目录下，新建一个名叫gitalk.swig的文件。hexo渲染模板的时候会自动读取该目录下的index.swig文件，然后根据配置文件里面定义的变量和模板文件里面的语句进行条件渲染。因此我们新建的模板文件也应该依葫芦画瓢：123456789101112131415161718&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %&#125; &#123;% if theme.gitalk.enable %&#125;、 &lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt; &lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var gitalk = new Gitalk(&#123; clientID: '&#123;&#123;theme.gitalk.clientID&#125;&#125;', clientSecret: '&#123;&#123;theme.gitalk.clientSecret&#125;&#125;', id: '&#123;&#123;page.title&#125;&#125;', repo: '&#123;&#123;theme.gitalk.repo&#125;&#125;', owner: '&#123;&#123;theme.gitalk.owner&#125;&#125;', admin: '&#123;&#123;theme.gitalk.admin&#125;&#125;', distractionFreeMode: &#123;&#123;theme.gitalk.distractionFreeMode&#125;&#125;, &#125;) gitalk.render('gitalk-container') &lt;/script&gt; &#123;% endif %&#125; &#123;% endif %&#125; 上面的代码会在渲染时插入到HTML文件里，因此必须注意script文件引入的顺序，否则可能会出现undefined等错误。随后在同目录下的index.swig文件末尾追加includegitalk.swig:1&#123;% include 'gitalk.swig' %&#125; 不过还没完，上面我们只是新增了Gitalk的调用，还得把它放到页面下方评论区才行。打开next/layout/_partials/comments.swig，在valine的后面追加：123&#123;% elseif theme.gitalk.enable and theme.gitalk.clientID and theme.gitalk.clientSecret %&#125; &lt;div id="gitalk-container"&gt;&lt;/div&gt;&#123;% endif %&#125; 修改配置文件根据上面的代码我们可以看出，是否渲染主要是根据theme.gitalk.enable和theme.gitalk.distractionFreeMode这两变量来的，并且Gitalk类需要的参数还有theme.gitalk.clientID和theme.gitalk.clientSecret等，那么相应的配置文件应该怎么写就不言而喻了，在主题配置文件_config.yml里面新增如下代码：123456789# Gitalkgitalk: enable: true clientID: #填写注册时获得的clientID clientSecret: #注册时获得的密钥 repo: #仓库名 owner: gaojianli #所有者的名字 admin: gaojianli #管理员名称 distractionFreeMode: false #这个用于输入框是否具有全屏遮罩 虽然理论上来说放哪里都成，不过为了方便管理还是和其他评论插件放到一起比较好。其中Admin字段是文章未初始化时显示的管理员的名字。保存之后运行hexo g应该就可以看到效果了。不过这样默认背景是透明的，显得非常突兀，因此我决定给它加上背景。直接调用内置的的class，再略微调整下margin就大功告成了：123&#123;% elseif theme.gitalk.enable and theme.gitalk.clientID and theme.gitalk.clientSecret %&#125; &lt;div class="post-block" id="gitalk-container" style="margin-top:10px"&gt;&lt;/div&gt;&#123;% endif %&#125; 效果展示未登录：商业互吹的评论区: 一些坑新发的文章可能出现如下的情况:可能是GitHub的限制吧，其他人通过Gitalk是没法主动创建issue的，换句话说，需要“初始化”。初始化的方法也非常简单：用管理员账号登录GitHub后打开相应的博文即可。 追加：一个小Bug自从撰写这篇文章之后已经过去了许多时间，前不久无意中发现了一个小Bug，那就是在tags页面hexo也渲染了评论区:既然是问题那就要解决，正巧今天中午无事，就来好好看看吧。首先我们要知道，NexT主题使用了各种各样的库，其中就有大名鼎鼎的jQuery，虽然JQ是著名的“JQ一时爽，维护火葬场”，但正常人没事也不会去修改主题文件。那么我就图个省事，直接用jQ进行修改吧。思路大概如下： 修改gitalk.swig，判断当前页面是否为tags页面 若是，直接移除id为gitalk-container的div即可既然是要判断页面是否存在，因此需要寻找特征元素，在这里我选取的是div.tag-cloud这一元素，因此直接判断是否存在即可，最终代码如下:1234567891011121314151617181920212223&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %&#125; &#123;% if theme.gitalk.enable %&#125;、 &lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt; &lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; if($(".tag-cloud").length===0)//判断元素是否存在 &#123; var gitalk = new Gitalk(&#123; clientID: '&#123;&#123;theme.gitalk.clientID&#125;&#125;', clientSecret: '&#123;&#123;theme.gitalk.clientSecret&#125;&#125;', id: '&#123;&#123;page.title&#125;&#125;', repo: '&#123;&#123;theme.gitalk.repo&#125;&#125;', owner: '&#123;&#123;theme.gitalk.owner&#125;&#125;', admin: '&#123;&#123;theme.gitalk.admin&#125;&#125;', distractionFreeMode: &#123;&#123;theme.gitalk.distractionFreeMode&#125;&#125;, &#125;) gitalk.render('gitalk-container') &#125; else if($(".page-home").length===0) //判断是否为主页 $("#gitalk-container").remove()//移除相应元素 &lt;/script&gt; &#123;% endif %&#125; &#123;% endif %&#125; 最终效果可以点击这里では、諸君は。]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建自己的Git]]></title>
    <url>%2F2018%2F07%2F13%2F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git%2F</url>
    <content type="text"><![CDATA[前言事情的起因非常简单，得益于某位校长的功劳，我的网络访问Github奇慢无比，最近甚至出现了push失败的情况，我连博客都没法好好更新了！（说的好像你更新得很多一样）嘛，正好潇在给我孜孜不倦地推荐Gitea，我就来试试在树莓派上搭建一下吧。首先我们来看官方文档： 易安装您除了可以根据操作系统平台通过 二进制运行，还可以通过 Docker 或 Vagrant，以及 包管理 安装。 嚯，挺厉害嘛，那就图个省事，用Docker安装吧。然而这之后我才知道，这是地狱的开始。 Docker试探安装官方的教程非常的简单，看起来就和能用一样 我们在 Docker Hub 的 Gitea 组织中提供了自动更新的 Docker 镜像，它会保持最新的稳定版。你也可以用其它 Docker 服务来更新。首先你需要pull镜像： 123docker pull gitea/gitea:latestsudo mkdir -p /var/lib/gitea //如果要将git和其它数据持久化，你需要创建一个目录来作为数据存储的地方docker run -d --name=gitea -p 10022:22 -p 10080:3000 -v /var/lib/gitea:/data gitea/gitea:latest //然后就可以运行 docker 容器了，这很简单。 当然你需要定义端口数数据目录： 这时候我才发现我根本就没有安装docker，赶紧apt解决：1apt install docker 然后开始pull，这时又要忍受国内网络的龟速：12345678910docker pull gitea/gitea:latestlatest: Pulling from gitea/gitea911c6d0c7995: Pull completefe8708a98e1d: Pull complete754e5dc9c218: Pull complete99ffba26b3d3: Pull completeee04a0c4cde1: Pull complete78a8e5235d3e: Pull completeDigest: sha256:6f28b3e5127f29f614b765738cf5e4d673b1a0762d42c095323433c26eef779dStatus: Downloaded newer image for gitea/gitea:latest 受阻尝试运行一下123# root @ rasp in ~ [14:46:44]$ docker run -d --name=gitea -p 10022:22 -p 10080:3000 -v /mnt/disk/Git:/data gitea/gitea:latestee43cb4883e4d6e75f0eea1c8b90988880c1569b7088bc1f072274f2a2eaf4dc 没有回显，不过还是先看看容器跑起来没有:123# root @ rasp in ~ [14:46:54]$ docker logs giteastandard_init_linux.go:185: exec user process caused &quot;exec format error&quot; 喵喵喵？这尼玛是啥？看起来好像是可执行文件架构不对。。 原因分析总之先inspect一下吧12# root @ rasp in ~ [14:55:17]$ docker inspect gitea/gitea:latest 得到如下结果:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126[ &#123; "Id": "sha256:67ff9596dc004fdbbd87289f854ef8fb2920ab66621155117f618290457f42c9", "RepoTags": [ "gitea/gitea:latest" ], "RepoDigests": [ "gitea/gitea@sha256:6f28b3e5127f29f614b765738cf5e4d673b1a0762d42c095323433c26eef779d" ], "Parent": "", "Comment": "", "Created": "2018-07-12T14:14:03.941666864Z", "Container": "9c524fa2972be8a9c2e777219e07bdb23c8a21a18cff8d7884f2df6c95795948", "ContainerConfig": &#123; "Hostname": "9c524fa2972b", "Domainname": "", "User": "", "AttachStdin": false, "AttachStdout": false, "AttachStderr": false, "ExposedPorts": &#123; "22/tcp": &#123;&#125;, "3000/tcp": &#123;&#125; &#125;, "Tty": false, "OpenStdin": false, "StdinOnce": false, "Env": [ "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", "USER=git", "GITEA_CUSTOM=/data/gitea" ], "Cmd": [ "/bin/sh", "-c", "#(nop) ", "LABEL org.label-schema.build-date=2018-07-12T14:11:41Z org.label-schema.vcs-ref=659bc727bd12bf219d80d38d8b634bd578ddb84f org.label-schema.vcs-url=https://github.com/go-gitea/gitea.git" ], "ArgsEscaped": true, "Image": "sha256:5789f396c54923dbf5643737a149337f5fc0c1fd0cc186f41ecc30c96b300e9a", "Volumes": &#123; "/data": &#123;&#125; &#125;, "WorkingDir": "", "Entrypoint": [ "/usr/bin/entrypoint" ], "OnBuild": null, "Labels": &#123; "maintainer": "maintainers@gitea.io", "org.label-schema.build-date": "2018-07-12T14:11:41Z", "org.label-schema.vcs-ref": "659bc727bd12bf219d80d38d8b634bd578ddb84f", "org.label-schema.vcs-url": "https://github.com/go-gitea/gitea.git" &#125; &#125;, "DockerVersion": "17.12.0-ce", "Author": "", "Config": &#123; "Hostname": "", "Domainname": "", "User": "", "AttachStdin": false, "AttachStdout": false, "AttachStderr": false, "ExposedPorts": &#123; "22/tcp": &#123;&#125;, "3000/tcp": &#123;&#125; &#125;, "Tty": false, "OpenStdin": false, "StdinOnce": false, "Env": [ "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", "USER=git", "GITEA_CUSTOM=/data/gitea" ], "Cmd": [ "/bin/s6-svscan", "/etc/s6" ], "ArgsEscaped": true, "Image": "sha256:5789f396c54923dbf5643737a149337f5fc0c1fd0cc186f41ecc30c96b300e9a", "Volumes": &#123; "/data": &#123;&#125; &#125;, "WorkingDir": "", "Entrypoint": [ "/usr/bin/entrypoint" ], "OnBuild": null, "Labels": &#123; "maintainer": "maintainers@gitea.io", "org.label-schema.build-date": "2018-07-12T14:11:41Z", "org.label-schema.vcs-ref": "659bc727bd12bf219d80d38d8b634bd578ddb84f", "org.label-schema.vcs-url": "https://github.com/go-gitea/gitea.git" &#125; &#125;, "Architecture": "amd64", "Os": "linux", "Size": 75448364, "VirtualSize": 75448364, "GraphDriver": &#123; "Data": &#123; "LowerDir": "/var/lib/docker/overlay2/9fce26ccc4b7e0aefe663ecb165615aadda2d2437b3ab7cafab599de5d055736/diff:/var/lib/docker/overlay2/a0cf2ef094b8fb958037aff40de9cf54cd2c1be580fbe2fe592b5839e1a08cd5/diff:/var/lib/docker/overlay2/29e0cfce429c5eba2e674761d6a27dc914a2432a5b87c4eb7168623f62f0ed35/diff:/var/lib/docker/overlay2/b37847000ccdd55f5acd0ea549f16073da142458dd7e1cc1487d5ce2ea944611/diff:/var/lib/docker/overlay2/c1e252414cf059e505f719e559a35d5635608c136cdac00bce2ecba73dbf5111/diff", "MergedDir": "/var/lib/docker/overlay2/196a454e1b7f7f5f0424e1afefd7a5b1b07edce529dca3f5b8a6a591f51de02f/merged", "UpperDir": "/var/lib/docker/overlay2/196a454e1b7f7f5f0424e1afefd7a5b1b07edce529dca3f5b8a6a591f51de02f/diff", "WorkDir": "/var/lib/docker/overlay2/196a454e1b7f7f5f0424e1afefd7a5b1b07edce529dca3f5b8a6a591f51de02f/work" &#125;, "Name": "overlay2" &#125;, "RootFS": &#123; "Type": "layers", "Layers": [ "sha256:717b092b8c86356cf976d9c83fa6f0ea67f2bf3148a5bbb7e02026a5d3245e68", "sha256:0c8bc7fe995df099706fa9de6efe8780873009fa9bd88c1d061a9da42208ce3d", "sha256:934a2cc01616c95aceffe2f7c906d0608e3d3e69d6c315e6b35980138b72bfa6", "sha256:13f47d251abf8fb04b518a7f78a626d3aa8edd19690cec8158972ad6297866a7", "sha256:5e395242ed599a17ffa4225218344a6ac2c336ba774be69ef59d5a4323f0a1e9", "sha256:dd6e07b2f31502448541c62eb16a27958f3a8cb91fafa8010961a72b209ccc43" ] &#125;, "Metadata": &#123; "LastTagTime": "0001-01-01T00:00:00Z" &#125; &#125;] 进入到LowerDir看一下？123# root @ rasp in /var/lib/docker/overlay2/9fce26ccc4b7e0aefe663ecb165615aadda2d2437b3ab7cafab599de5d055736/diff/app/gitea [15:18:01]$ lsgitea 只有一个执行文件，这时候需要请出file大法了123# root @ rasp in /var/lib/docker/overlay2/9fce26ccc4b7e0aefe663ecb165615aadda2d2437b3ab7cafab599de5d055736/diff/app/gitea [15:18:02]$ file giteagitea: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-x86_64.so.1, stripped やっぱり！™这个文档谁写的！头伸过来，看我不来给你加个bug，你写这个文档的时候就没考虑过其他架构的CPU的感受么！你是不是看不起ARM！！ 最后的挣扎嘛，既然这样了，摆在我面前也就三条路: 制作基于ARM64的docker容器 放弃docker 玩一些骚操作 首先来看看骚操作，既然它的运行依靠的是单文件，那我如果下载arm64的二进制文件手动替换，不就可以运行了么？但是事实狠狠的打了我的脸，前面的替换进行地很顺利，直到…12345678910111213141516171819202122root@rasp:/var/lib/docker/overlay2# cd b37847000ccdd55f5acd0ea549f16073da142458dd7e1cc1487d5ce2ea944611/diff/bin/root@rasp:/var/lib/docker/overlay2/b37847000ccdd55f5acd0ea549f16073da142458dd7e1cc1487d5ce2ea944611/diff/bin# lsbackground fdreserve multisubstitute s6-fdholder-list s6-ipcserver s6-svlisten1backtick fdswap pipeline s6-fdholder-listc s6-ipcserver-access s6-svokbash forbacktickx piperw s6-fdholder-retrieve s6-ipcserverd s6-svscanbashbug foreground redirfd s6-fdholder-retrievec s6-ipcserver-socketbinder s6-svscanctlcd forstdin runblock s6-fdholder-setdump s6lockd s6-svstatdefine forx s6-accessrules-cdb-from-fs s6-fdholder-setdumpc s6-log s6-svwaitdollarat getcwd s6-accessrules-fs-from-cdb s6-fdholder-store s6-mkfifodir s6-tai64nelgetopt getpid s6-applyuidgid s6-fdholder-storec s6-notifyoncheck s6-tai64nlocalelgetpositionals heredoc s6-cleanfifodir s6-fdholder-transferdump s6-setlock shiftelglob homeof s6-connlimit s6-fdholder-transferdumpc s6-setsid trapemptyenv if s6-envdir s6-fghack s6-setuidgid tryexecexec ifelse s6-envuidgid s6-ftrig-listen s6-softlimit ucspilogdexeclineb ifte s6-fdholderd s6-ftrig-listen1 s6-sudo umaskexit ifthenelse s6-fdholder-daemon s6-ftrig-notify s6-sudoc unexportexport import s6-fdholder-delete s6-ftrigrd s6-sudod waitfdblock importas s6-fdholder-deletec s6-ftrig-wait s6-supervise withstdinasfdclose loopwhilex s6-fdholder-getdump s6-ioconnect s6-svcfdmove multidefine s6-fdholder-getdumpc s6-ipcclient s6-svlistenroot@rasp:/var/lib/docker/overlay2/b37847000ccdd55f5acd0ea549f16073da142458dd7e1cc1487d5ce2ea944611/diff/bin# file bashbash: ELF 64-bit LSB pie executable x86-64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-x86_64.so.1, stripped 惹不起，惹不起，告辞！至于编译，我实在不想弄，理由如下：首先，有了上次编译驱动的经历之后，我是再也不想在树莓派上编译任何东西了。且不说CPU的弱鸡，光是内存不足就足够你喝一壶的。至于交叉编译？不好意思，编译之神Baymax持续掉线中。 二进制安装那就只有来二进制文件了。嘛，这个就没啥说的了，直接参照官方教程就好了。配置文件随便根据官网改改就好，这里就不贴出来。 最终效果Gitea嘛，就是这样，试过了速度还行。还拥有镜像功能，可以自动追踪某一个远程仓库，以后有啥小项目就决定是你了！では、諸君は。]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>Web</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微软Insider DevTour小记]]></title>
    <url>%2F2018%2F06%2F28%2F%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言前一阵子收到了微软发给所有的insider的邀请邮件，大意说是DevTour即将巡回到北京，欢迎参加云云。弱鸡表示从来没听过这个名字，吓得我赶紧百度了一下： 每年，我们都将最新的技术带给全球的开发者。今年，我们通过与Windows、Windows Insider项目以及我们的开发者和内部人士的合作伙伴关系，将活动扩展到更多的城市。我们将介绍人工智能，最新的桌面开发，微软365，进步网络应用，开发者办公室，混合现实，Microsoft Graph，等等。此次巡回活动是开发者与来自微软总部雷德蒙德的领导和工程师以及地区行业领先和微软开发者MVPs和RDs相互直接交流的一次绝佳机会。 概括一下大概就是5个字：大佬见面会然而不幸的是这一天恰好是我考高数的日子，以前处在偏远山区的我看见这类活动只能望汤兴叹，好容易在北京，怎么能就这样鸽了呢？于是乎赶紧发邮件问了一下能否下午到场，所幸得到了肯定的答复: 到达不得不吐槽沙河校区的偏远程度超乎想象，上午高数凉了（迫真）以后即使我以最快速度向会场赶，最终在会议开始前最后一刻才成功赶到。走进酒店，首先看见的就是指引牌。和我想象的不一样，微软并没有大张旗鼓地打印海报，仅仅是在门口放了个一人高的牌子，这与其选择如此昂贵酒店的土豪作风反而显得格格不入。快速完成了签到后领到了参会牌和会议集章册，后者印着会议日程，虽然是早已公布在网站上的： 签到 开始签到 主题演讲 茶歇时间 如何在Windows 10上，进化您现有的应用程序 如何充分利用PWA开发Web App 午餐 基于 Azure Kubernetes Services 的DevOps 全生命周期流水线 如何使用Office 365创建高效应用程序 如何使用Microsoft Graph在所有设备上提升用户参与度 茶歇时间 边缘计算中的智能化 - 机器学习入门 构建Windows混合现实应用程序 If(dev) { Insider(); } 互动问答进入会场的时候，里面似乎正在进行类似一站到底的游戏，当然题目都是编程方面的，从Visual Basic到C#无所不包，（据说Basic的题目淘汰了许多年轻人）。其题目更多的是考察诸如位运算这种深层次的理解。下面是只剩两人的时候的巅峰对决，你能说出答案么？当然也不乏这种让人跑路的逗逼题目: Which command can exit vim?Head:”:wq” Tails:”rm -rf /“ 上半场最终夺冠的是右边的小哥，在他选择完奖品之后，讲座终于正式开始 DevOps这一节主要讲的是k8s和DevOps对于产品开发流程的构建。 首先主讲人Lei Xu给我们回顾了一下软件开发的架构变化:现如今，软件的生命周期更多地向组件化，容器化发展，开发者开始更多的着眼于软件的开发，而不再去担心服务器环境的配置。Iaas的出现让开发者不用再去关心服务器的供电、网络等问题，云主机的出现则免去了操作系统和相关业务软件的配置和维护。而Docker则将软件的运行环境和系统环境实现了分离，开发环境和生产环境的差异不再是个问题。然而，即使采用了docker，容器依旧需要命令行进行管理、维护，与此同时至于k8s，先看看官方（百度）定义： Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。如果你曾经用过Docker容器技术部署容器，那么可以将Docker看成Kubernetes内部使用的低级别组件。 k8s可以理解为一种类似腾讯云的管理平台。只不过腾讯云你开的是云主机，k8s开的是一个个容器，在这个平台上，你完全不用担心宿主机的运行状况，你的眼中有的只有一个个容器，一个个微服务。但是k8s的配置是极其复杂的，Xu在场上做了一个调查，与会的诸位中配置过k8s的只有一个人。应对这个问题，Azure提供了一个一键式平台解决方案，国内提供类似服务的好像还有阿里云。至于DevOps，软工的诸位一定不会陌生，这是一种软件开发生命周期的解决方案。不过别看他说的神乎其神，微软的提供的主要是以VSTS和Azure为中心展开的业务，后者没用过不了解，但前者其实诟病甚多。主要是操作逻辑感人，喜欢把简单问题复杂化，我找个删除找了半个小时。此外Work Item的分配竟然要一个非常睿智的Query来查看，而且和宇宙第一IDE的结合也不甚完美，当然也可能是我不会用吧。毕竟人家有个岗位可是叫做DevOps工程师呢。值得一提的是，可能是Azure在Edge上翻车翻多彻底绝望了吧，现场演示的计算机换成了一台运行着Chrome的Mac，有图为证（有点糊了）：最后的最后，在玩滥的One more thing..之后，他介绍了一个叫做DevOps魔盒的东东，反正就是个一条龙服务，感兴趣的可以关注一下。 Teams app开发关于这方面，由于我并不是Office 365的订阅者，因此我并不是很清楚。大意就是Office又填了一个新成员叫做Teams，应该是用于团队协作用的。这个Teams可以添加各种各种各样的web apps用于团队合作。然后这些app可以调用各种各样的数据，如下： Audio and video conferencing Permanent chat Online meetings and broadcasts Shared files in SharePoint Team notes in OneNote Team tasks in Planner Shared email inbox, calendar and email address Available for web, desktop and mobile 这些app主要分为两类:Tabs和Bots，前者是作为一个选项卡嵌入Teams，有点类似组件，后者顾名思义是机器人。项目基于万能的html和Typescript开发，支持Visual Studio远程调试不过我并没有在国内看到什么人使用，也没听说哪个公司大规模购置了office 365，毕竟在你国万物可是都有替代的： 版本控制？那是什么？用QQ群就够了团队协作？Sharepoint?不需要，我有QQ群视频会议？Skype？对不起，我还是又QQ群Teams?没听过的东西，能有QQ群好用么？ 毕竟，那句话咋说的来着？又不是不能用 Microsoft Graph这个我觉得是今天下午的重中之重了，由Justin Liu给我们带来。虽然错过了上午的PWA有点可惜，不过听了这个便已经不虚此行了，你看我手都抖得不能自已了: 那么什么是MS Graph呢？Graph是微软提供的一组用于获取基于微软各项服务中产生的各种数据的api（挺绕口的），通俗地说就是你在使用微软各项服务的时侯他收集了你的隐私，然后提供了一些接口让你能够利用这个数据。我们评判一个数据提供方最主要的指标就是数据数量以及质量，那么，这个数据量究竟有多大呢，微软给了张图: 可以看到这个数据量是非常可观的，来源也非常广泛，例如Office365、Outlook、Onedrive，甚至Windows 10的Timeline。可以说，只要你使用过微软相关的云服务，你就都会有记录下来。那么究竟有那些数据呢？API主要分为两类，User和Activity。前者包含的主要是用户的基本信息以及人脉信息，可以获取例如我的工作伙伴，我的照片，我的邮箱等个人信息，API以/me打头，后接简单的单词，通过GET或者POST发送请求，然后服务器返回JSON，如图所示：相信看到这里，有些小伙伴心里面已经有一些应用场景了，如果没有的话请再看下面这张图： 是不是觉得挺眼熟？没错，前端中常见的组件化数据绑定和模板渲染！这简直是为Vue.js这种数据绑定的框架量身定制的，有这些API做个个人dashboard或者智能助理完全不是问题。值得注意的是，这里官方给的Demo是追踪日历变化，在会议时长占比超过80%的时候自动提示，其关于人脉方面的API数据来源则是Office Teams，因此对于没有使用Office 365的小伙伴来说，这部分功能算是废了。不过尽管如此，剩下的API也依旧让人兴奋。Microsoft Graph除了获取数据的API外，还提供了一些动作性API用于执行发送邮件等主动操作，主要通过POST访问，例如下面这个自动文档审批工作流： 前面我提到了组件化和数据绑定，微软也提出了一种新型控件（暂时姑且这么叫）Adaptive Card 这是一种可适应性的卡片数据交换方式，或者应该叫可适应模板。之所以被称为可适应，是因为它采用json方式传入数据，而根据应用场景的不同可以渲染成不同的样子，例如小娜消息，Skype消息，Windows Timeline等等，亦即“一份数据，万种表现”。前面提到了Graph的API还有Activity这一大类，其全名是Activity &amp; Device，从名字上我们可以看出，这一类主要是偏向用户对设备的使用，而不是依赖于某个软件 通过这组API我们可获取到Windows上的应用使用情况，推送Timeline消息，向特定设备推送消息等。随后，Justin展示了如何在Windows10 1803上自定义显示TImeline消息，支持对标题、显示信息甚至背景实施自定义。 幕间讲座到此暂歇，我也出去逛了逛喝口水，看了看一辈子也买不起的Hololens（本来是想体验的。。人太多了ORZ）在此我要大喊：微软牌蛋糕真好吃！ 下半场下午3点半，讲座继续。 WindowsML主讲继续是Nikola Metulev大佬，他一手打造了UWP community tookit的，他的英语是唯一一个不用传译器能听懂的，其他印度英语惹不起。说实话，我一看是看见WindowsML的时候是把它看成了MR，后来又当作标记语言，直到今天我才知道这是Machine Learning的意思。 说到机器学习，常规方法是通过服务器（炼丹炉）对成千上万的样本进行训练，然后得到模型进行评估，而且这种训练多半是发生在Linux上的，似乎与Windows无缘。但是，在海量样本的收集过程中，免不了会收集大量的隐私，而这对于多数用户来说是不可忽视的。因此AI在边缘计算中的重要性也在不断提高，而作为桌面上最流行的操作系统，WindowsML的存在就显得尤为必要。随后，他在Surface book 2上演示了实时的摄像头画面处理： 这除了说明Surface Book 2性能很强（广告嫌疑）外，也说明了WindowsML具有不错的性能。然而，如果就仅仅如此的话，WindwosML也并没有什么太过出彩的地方，也难以吸引别人放弃流行的Linux平台转投Windows。人们谈起机器学习，除了其烧钱的硬件外，混合高等数学、概率论、线性代数的理论知识其实更加令人头痛，大名鼎鼎的西瓜书更是手边不能离开数学教材。如此种种都说明了一个事实，大部分程序员没有独自设计神经网络的理论知识和能力。而这也就是WindowsML震撼的地方,Nikola给我们当场演示了一个关于面部表情识别的demo，他向Visual Studio中拖拽了一个ONNX格式的网络模型文件，VS自动生成了相应的Input和Output函数，神经网络的使用被简化成了黑箱！输入数据，吐出数据，仅此而已。程序员可以无需关心网络实现，直接调用，而且并不局限于Python等少数语言。 那么，如何去获得ONNX文件呢？这张图给出了几种可能的方法: 前两种方法姑且不提，下载现成的文件和从其他模型文件转换大家都不难想到。后两种则是直接提供了一种不用写代码就能构建神经网络的方法！在他的现场演示中，用户只需要直接选择模型类别（分类器/目标识别），然后按标签上传图片就可以了，Azure甚至会自动在云端帮你进行训练（速度还不慢）。训练完成后得到的ONNX文件则可以直接使用！从炼丹炉到炼丹术，Azure都帮你做完了，用户只要等着就好了。 Windows 混合现实没钱，买不起，没听，下一个 If(dev) { Insider(); }这个环节其实更多的是在介绍Insider项目的意义，主讲是Tyler Ahn大妈。她主要举了几个依靠insider成功的例子，得出了{Insider(sth);}≠{Insider=true;}这一结论。Insider计划是让million的人代表billion的人，同时给开发者一个机会，一个平台去实现他们的goal。个人感觉没啥干货，就口号喊得好听: Make your good code into great business. ##F&amp;Q作为最后一个环节，提问，大家参与度还是非常踊跃地，看看这排队的人： 其实部分问题还是挺尖锐的，包括消费者买得起的Hololens何时推出？有没有开源Groove音乐等Windows内置APP的可能来给开发者提供参考？Fluent Design能用在Web和Mobile上么？关于最后一个问题，Justin让希望在Web上看见Fluent Design的举手，其结果自然是全场齐举，莫名壮观。Material Design可能要有对手了。 总结第一次参加DevTour这类活动，挺新奇的的。不过感觉收获挺大，了解到了很多很多的黑科技。同时“原来有这种东西，我之前做的XXX到底有什么意义！”这种感觉也让人爱恨交织。最后的最后，如果要用两个字来形容这次活动的话，好吃！では、諸君は。]]></content>
      <tags>
        <tag>讲座</tag>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面]]></title>
    <url>%2F2018%2F06%2F12%2F%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[思前想后，看见大家都有了，我还是开一个博客吧。之前一直懒得弄的原因是担心自己没有动力去写文章。但是，怎么说呢，完事开头难，人家潇都有了我怎么能没有呢！（笑）也有这么一种不服气在里面就是了。那就这样吧，希望能够坚持下去。では、諸君は。]]></content>
  </entry>
</search>
